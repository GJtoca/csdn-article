> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/m0_61712829/article/details/132433502)

**目录**

[中断系统](#t0)

[中断执行流程](#t1)

[STM32 中断](#t2)

[NVIC 基本结构](#t3)

[NVIC 优先级分组](#t4)

[EXTI 简介](#t5)

[EXTI 基本结构](#t6)

[AFIO 复用 IO 口内部电路](#t7)

[EXTI 内部电路框图](#t8) 

[EXTI 外部中断的特性和使用场景](#t9)

[手册](#t10)

[补充](#t11)

[0. 江协科技 / 江科大 - STM32 入门教程 - 各章节详细笔记 - 查阅传送门 - STM32 标准库开发_stm32 江协大 csdn-CSDN 博客文章浏览阅读 3.4k 次，点赞 47 次，收藏 143 次。江协科技 / 江科大 - STM32 标准库开发 - 各章节详细笔记 - 传送门至各个章节笔记。基本上课程讲的每句都详细记录，方便回顾。_stm32 江协大 csdn![](https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png)https://blog.csdn.net/m0_61712829/article/details/132434192?spm=1001.2014.3001.5501](https://blog.csdn.net/m0_61712829/article/details/132434192?spm=1001.2014.3001.5501 "0. 江协科技/江科大-STM32入门教程-各章节详细笔记-查阅传送门-STM32标准库开发_stm32江协大 csdn-CSDN博客")

中断系统是管理和执行中断的逻辑结构，[外部中断](https://so.csdn.net/so/search?q=%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD&spm=1001.2101.3001.7020)是众多能产生中断的外设之一，所以本节我们就借助外部中断来学习一下中断系统。在以后学习其它外设的时候，也是会经常和中断打交道的。

### 中断系统

中断：在主程序运行过程中，出现了特定的中断**触发条件（中断源**。比如对于外部中断来说，可以是引脚发生了电平跳变；对于定时器来说，可以是定时的时间到了；对于串口通信来说，可以是接收到了数据），使得 CPU 暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。（就好比晚上睡觉前定了个闹钟，时间到了提醒你，不管时间到不到你可以安心睡觉）。

中断优先级：当有多个中断源同时申请中断时，CPU 会根据中断源的**轻重缓急**进行裁决，优先响应更加**紧急**的中断源。（这个中断优先级是我们根据程序设计的需求，自己设置的）。

中断嵌套：（**中断程序再次中断，二次中断现象**）当一个中断程序正在运行时，又有**新的更高优先级**的中断源申请中断，CPU 再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回。（也是为了照顾非常**紧急**的中断）。

### 中断执行流程

中断程序的执行流程如下，当它执行到某个地方时，外设的中断条件满足了，那这时，无论主程序是在干什么事情（比如 OLED 显示程序才执行一半，Delay 函数还在等待等）中断来了，主程序都得立即暂停，程序由硬件电路自动跳转到中断程序中，当中断程序执行完之后，程序再返回被暂停的地方继续运行（这个暂停的地方，叫做**断点**）。为了程序能在中断返回后继续原来的工作，在中断执行前，会对程序的现场进行保护，中断执行后，会再返回现场，这样保证主程序被中断了，回来之后也能继续执行。

![](https://i-blog.csdnimg.cn/blog_migrate/33ed23476d8921ccd7bd304c7eb48004.png)

中断嵌套的执行流程如下。当一个中断正在执行时，又有新的优先级更高的中断来，那个旧中断会被打断，执行新的中断，新的中断结束，再继续执行原来的中断，原来的中断结束，再继续主程序，这就是中断嵌套的执行流程。

![](https://i-blog.csdnimg.cn/blog_migrate/8d19262faeb0d1b7377e629a405e6fa9.png)

c 语言中，中断的执行流程如下。上面是主函数，while（1）死循环里就是主程序，正常情况下，程序就是在主程序中不断循环执行，当中断条件满足时，主程序就会暂停，然后自动跳转到中断程序里运行，中断程序执行完之后，再返回主程序执行。一般中断程序都是在一个子函数里，这个函数不需要我们调用，当中断来临时，**由硬件自动调用这个函数**，这就是在 c 语言中，中断的执行流程。

![](https://i-blog.csdnimg.cn/blog_migrate/85dbfe44c3a4b6a2f1dd110dcea56316.png)

### STM32 中断

多个可屏蔽中断通道（中断源），包含 EXTI（外部中断）、TIM、ADC（模数转换器）、USART（串口）、SPI、I2C、RTC（实时时钟）等多个外设。（几乎所有模块都能申请中断）

使用 [NVIC](https://so.csdn.net/so/search?q=NVIC&spm=1001.2101.3001.7020) 统一管理中断，每个中断通道都拥有 16 个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。

NVIC 就是 STM32 中用来管理中断、分配优先级的，NVIC 的中断优先级共有 16 个等级。

EXTIx 是外部中断对应的中断资源。

下图为 stm32 的中断资源，上面灰色的是内核中断（我们一般不用，了解即可），下面不是灰色的部分就是 stm32 外设的中断了，外设电路检测到有什么异常或事件，需要提示一下 CPU 的时候，它就可以申请中断，让程序调到对应的中断函数里运行一次，用来处理这个异常或事件。图中最右边是中断的地址，因为程序中的中断函数，它的地址是由编译器来分配的，是不固定的，但是我们的中断跳转，由于硬件的限制，只能跳到固定的地址执行程序，所以为了硬件能够跳转到一个不固定的中断函数里，这里就需要在内存中定义一个地址的列表，这个列表的地址是固定的，中断发生后，就跳到这个固定位置，然后在这个固定位置，由编译器，再加上一个跳转到中断函数的代码，这样中断跳转就可以跳转到任意位置了，这个中断地址的列表，就叫**中断向量表**，相当于中断跳转的一个跳板，不过**我们用 c 编程，是不需要管这个中断向量表的**，因为编译器都帮我们做好了。![](https://i-blog.csdnimg.cn/blog_migrate/4d1bdcc70c13feb87efbb31efe9a8ec8.png)

![](https://i-blog.csdnimg.cn/blog_migrate/7a4334198b65c6c512982fd69d19e07c.png)

### NVIC 基本结构

NVIC（**嵌套中断向量控制器**），在 stm32 中，它是用来统一分配中断优先级和管理中断的，**NVIC 是一个内核外设**，是 CPU 的小助手（如果把中断全接到 cpu 上，会很麻烦，毕竟 CPU 主要是用来运算的），NVIC 有很多输入口，下图中线上划了个斜杠上面写了 n（这个意思是：**一个外设可能会同时占用多个中断通道，所以这里有 n 条线**），然后 NVIC 只有一个输出口，NVIC 根据每个中断的优先级分配中断的先后顺序，之后通过右边这一输出口就告诉 CPU 该处理哪个中断，对于中断先后顺序分配的任务，CPU 不需要知道

举个例子：比如 **CPU** 是医生，如果医院只有一个医生时，当看病人很多时，医生就得先安排一下先看谁后看谁，如果有紧急的病人，那还得让紧急的病人最先来，这个安排先后顺序的任务很繁琐会影响医生看病的效率，所以医院就安排了一个叫号系统（**NVIC**），来病人了统一取号并且根据病人的等级，分配一个优先级，然后叫号系统看一下现在在排队的病人，优先叫号紧急的病人，最后叫号系统给医生输出的就是一个一个排好队的病人，医生就可以专心看病了。（**EXTI、TIM、ADC 等就是病人**）

![](https://i-blog.csdnimg.cn/blog_migrate/ec299dee0bb00920d20b340d8e0b2b19.png)

### NVIC 优先级分组

为了处理不同形式的优先级，STM32 的 NVIC 可以对优先级进行分组，分为抢占优先级和响应优先级。

**抢占优先级和响应优先级的区别，例子理解**：还想一下病人叫号的例子，对于紧急的病人，其实有两种形式的优先。一种是，上一个病人 1 在看病，外面排队了很多病人，当病人 1 看完后，外面排队中的紧急病人最先进去看病即使这个紧急病人是最后来的，这种**在排队中的插队的就叫响应优先级**，响应优先级高的可以插队提前看病。另一种是，上一个病人 1 在看病，外面排队中的病人 2 比病人 1 更加紧急，病人 2 可以不等病人 1 看完直接冲到医生的屋里，让病人 1 先靠边站，先给病人 2 看病，病人 2 看完病接着病人 1 看病，然后外面排队的病人再进来，这种形式的优先级就是中断嵌套，**这种决定是不是可以中断嵌套的优先级，就叫抢占优先级**，抢占优先级高的，可以进行中断嵌套。

为了将优先级区分为抢占优先级和响应优先级，就需要对这 16 个优先级优先级进行分组，NVIC 的中断优先级由优先级寄存器的 4 位（0~15，4 位二进制，对应 16 个优先级）决定，这 4 位可以进行切分，分为高 n 位的抢占优先级和低 4-n 位的响应优先级

优先级的**数值越小，优先级越高**，0 就是最高优先级

**抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队**，抢占优先级和响应优先级均相同的按中断号排队（中断号是中断表的左边数字，数值小的优先响应），所以 stm32 的中断不存在先来后到的排队方式，在任何时候都是优先级高的先响应。

下表，因为优先级总共是 4 位，所以就有（0,4）、（1.3）、（2，2）、（3,1）、（4、0）这五种分组方式，分组 0，就是 0 位的抢占等级，取值为 0，4 位的响应等级，取值为 0~15，分组 1234 雷同。这个分组方式是我们在程序中自己进行选择的，选好分组方式后，就要注意抢占优先级和响应优先级的取值范围了，不要超出这个表里规定的取值范围。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><p>分组方式</p></td><td><p>抢占优先级</p></td><td><p>响应优先级</p></td></tr><tr><td><p>分组 0</p></td><td><p>0 位，取值为 0</p></td><td><p>4 位，取值为 0~15</p></td></tr><tr><td><p>分组 1</p></td><td><p>1 位，取值为 0~1</p></td><td><p>3 位，取值为 0~7</p></td></tr><tr><td><p>分组 2</p></td><td><p>2 位，取值为 0~3</p></td><td><p>2 位，取值为 0~3</p></td></tr><tr><td><p>分组 3</p></td><td><p>3 位，取值为 0~7</p></td><td><p>1 位，取值为 0~1</p></td></tr><tr><td><p>分组 4</p></td><td><p>4 位，取值为 0~15</p></td><td><p>0 位，取值为 0</p></td></tr></tbody></table>

### EXTI 简介

EXTI（Extern Interrupt）外部中断

EXTI 可以监测指定 GPIO 口的电平信号，当其指定的 GPIO 口产生电平变化时，EXTI 将立即向 NVIC 发出中断申请，经过 NVIC 裁决后即可中断 CPU 主程序，使 CPU 执行 EXTI 对应的中断程序。（简单说：**引脚电平变化，申请中断**）

支持的触发方式（引脚电平的变化类型）：上升沿（电平从低电平变到高电平的瞬间触发中断）/ 下降沿（电平从高电平变到低电平的瞬间触发中断）/ 双边沿（上升沿和下降沿都可以触发中断）/ 软件触发（程序执行代码就能触发中断）

支持的 GPIO 口（外部中断引脚）：所有 GPIO 口都能触发中断，但相**同的 Pin 不能同时触发中断**（比如 PA0 和 PB0 不能同时使用，智能选一个作为中断引脚；所以如果有多个中断引脚要选择不同的 pin 引脚，比如 PA0 和 PA1、PB3 就可以）

通道数：总共有 20 个中断线路。16 个 GPIO_Pin（对应 GPIO_pin0 到 15，是外部中断的主要功能），外加 PVD 输出、RTC 闹钟、USB 唤醒、以太网唤醒（这 4 个中断线路，是因为外部中断有个功能是从低功耗模式的停止模式下唤醒 STM32 那对于 PVD 电源电压检测，当从电源从电池过压恢复时就需要 PVD 借助一下外部中断的退出停止模式；对于 RTC 闹钟来说，有时候为了省电，RTC 定一个闹钟之后，STM32 回进入停止模式，等到闹钟响的时候再唤醒，这叶需要借助外部中断，剩余 USB 唤醒、以太网唤醒也是类似的作用）

触发响应方式：**中断响应**（**引脚电平触发中断，申请中断，让 CPU 执行中断函数**）/ **事件响应**（**不会触发中断，而是触发别的外设操作**，属于外设之间的联合工作。外部中断的信号不会通向 CPU 而是通向其它外设，用来触发其它外设的操作，比如触发 ADC 转换、触发 DMA 等）

### EXTI 基本结构

外部中断的整体结构图如下：

首先，最左边是 **GPIO 口的外设**，每个 GPIO 外设有 16 个引脚，所以进来 16 根线；如果每个引脚占用一个通道，那 EXTI 的 16 个通道是不够用的，所以在这里会有一个 AFIO 中断引脚选择的电路模块，这个 **AFIO 就是一个数据选择器**（可以将图中前面的 3 个 GPIO 外设的 16 个引脚中的其中一个连接到后面的 EXTI 通道（16 个 GPIO 通道），**所以对于 PA0\PB0\PC0 这些，通过 AFIO 选择之后只有其中一个能接到 EXTI 的通道 0 上**），然后通过 AFIO 选择后的 16 个通道，就能接到了 EXTI 边沿检测及控制电路上，同时下面这 4 个蹭网的外设（PVD\PTC\USB\ETH）也是并列接进来的，这些加起来就**组成了 EXTI 的 20 个输入信号**，然后经过 EXTI 电路之后，**分为了两种输出，也就是中断响应和事件响应**（上面接到了 NVIC 用来触发中断，下面有 20 条输出线路到了其它外设，也就是事件响应）

注意点：EXTI9_5 是外部中断的 5,6,7,8,9 分到了一个通道里，EXTI15_10 也是一样；也就是说外部中断的 9 到 5 会触发同一个中断函数，15 到 10 也会触发同一个中断函数；在编程的时候，我们在这两个中断函数里，需要再根据标志位区分到底是哪个中断进来的。（本来 20 路输入，应该有 20 路中断的输出，可能 20 个输出太多了比较占用 NVIC 的通道资源，所以就把其中的外部中断 9~5，15~10，给分到了一个通道）

![](https://i-blog.csdnimg.cn/blog_migrate/031795cc2a2afcd8c3219f7a9ea0d04a.png)

### AFIO 复用 IO 口内部电路

内部电路就是一系列的数据选择器，如下图的最上面输入是 PA0\PB0\PC0 等尾号都是 0，然后通过数据选择器最终选择一个，连接到 EXTI0 上，上面写的文字是说配置这个寄存器的哪一个位就可以决定选择哪一个输入，图中后面部分内容都雷同。

AFIO 主要用于引脚复用功能的选择和重定义（也就是数据选择器的作用）。

在 STM32 中，AFIO 主要完成两个任务：复用功能引脚重映射（就是最开始提到的**引脚定义表**，当想把**默认复用功能换到重定义功能时，就是用 AFIO 来完成的**，这也是 AFIO 的一大主要功能）、中断引脚选择。

![](https://i-blog.csdnimg.cn/blog_migrate/e6c12b4f8e0e6d0a727eea991665b626.png)

### EXTI 内部电路框图 

EXTI 的右边就是 20 根输入线，然后输入线首先进入边沿检测电路，在上面的上升沿寄存器和下降沿寄存器可以选择是上升沿触发还是下降沿触发或者两个都触发，接着硬件触发信号和软件中断寄存器的值就进入到这个或门的输入端（也就是任意一个为 1，或门就可以输出 1），然后触发信号通过这个或门后就兵分两路，上一路是触发中断的，下一路是触发事件的：触发中断首先会置一个挂起寄存器（挂起寄存器相当于一个中断标志位，可以读取这个寄存器判断是哪个通道触发的中断，如果挂起寄存器置 1，它就会继续向左走和中断屏蔽寄存器共同进入一个与门（**与门实际上就是开关控制**作用，中断屏蔽寄存器给 1 那另一个输入就是输出，也就是允许中断；中断屏蔽寄存器给 0，那另一个输入无论是什么，输出都是 0，相当于屏蔽了这个中断），然后是 NVIC 中断控制器）。接着就是下一路的选择是触发事件，首先也是一个事件屏蔽寄存器进行开关控制，最后通过一个吗，脉冲发生器到其它外设（脉冲发生器就是给一个电平脉冲，用来触发其它外设的动作）

补充：框图最上面两个就是外设接口和 APB 总线，我们可以通过总线访问这些寄存器。

![](https://i-blog.csdnimg.cn/blog_migrate/bf4d867e3ff53f95a8cedacc930d8d4f.png)

### EXTI 外部中断的特性和使用场景

1. 什么样的设备需要用到外部中断，使用外部中断有什么好处呢？大概总结了使用外部中断模块的特性：就是对于 stm32 来说，想要获取的信号是**外部驱动的很快的突发信号。**

2. 外部中断的使用场景。比如，旋转编码器的输出信号，可能很久都不会拧它，这时不需要 stm32 做任何事情，但是我一拧它，就会有很多脉冲波形需要 stm32 接收，这个信号是突发的，stm32 不知道什么时候会来，同时它是外部驱动的，stm32 只能被动读取，最后这个信号非常快，stm32 稍微晚一点来读取就会错过很多波形，所以对于这种情况来说，就可以考虑使用 stm32 的外部中断，有脉冲过来，stm32 立即进入中断函数处理，没有脉冲的时候 stm32 就专心做其他事情；另外还有比如，红外遥控接收头的输出，接收到要遥控数据之后，它会输出一端波形，这个波形转瞬即逝，并且不会等你，所以就需要使用外部中断来读取；最后还有按键，虽然它的动作是外部驱动的突发事件但我并不推荐使用外部中断来读取按键，因为外部中断不好处理按键抖动和松手检测，对于按键来说，它的输出波形也不是转瞬即逝的，所以要求不高的话可以在主程序中循环读取，也可以考虑一下定时器中断读取的方式（这样即可以后台读取按键值、不会阻塞主程序也可以很好的处理按键抖动和松手检测的问题）

### 手册

大概看一下每个外设在手册的介绍

NVIC 是内核外设，在这个内核 cortex-m3 编程手册中查看，这个 cortex-m3 编程手册就是内核和内核外设的详细介绍，想研究一下内核的运转，可以看一下这个手册

![](https://i-blog.csdnimg.cn/blog_migrate/02ba6002538296f849307bcd82651ed5.png)

 ![](https://i-blog.csdnimg.cn/blog_migrate/8b1ea89e568e6c61239018aaed3118fb.png)

 NVIC 的一些寄存器

![](https://i-blog.csdnimg.cn/blog_migrate/46da83d0a5001d4f6481327875772348.png)

这个中断优先级寄存器就是用来设置每个中断的优先级的，用库函数直接给结构体赋值就行了，要知道库函数要最终落实到寄存器上来的

![](https://i-blog.csdnimg.cn/blog_migrate/8d5a5a347ea52cbd3efd5fd7d9972eae.png)

 中断分组配置寄存器被分配到了这个 SCB 里面

![](https://i-blog.csdnimg.cn/blog_migrate/0905d0340ef9bbe733f097847e2d183a.png)

![](https://i-blog.csdnimg.cn/blog_migrate/d4b653cecb012e957a2e2613ee03ef84.png) 这三位就是用来配置中断分组的

 中断和外部中断的介绍在参考手册中![](https://i-blog.csdnimg.cn/blog_migrate/8e6ffbe1bf6bdd41ff33016654368e9f.png)

 AFIO 介绍

![](https://i-blog.csdnimg.cn/blog_migrate/c3ce5d933c2aef6ebf18594a8a340632.png)

### 补充

![](https://i-blog.csdnimg.cn/blog_migrate/6174cabbe15ba012fd16458b94c0f9dd.png)**或门（无直边）**。它可以有多个输入，但只能有一个输出。执行的是或的逻辑，在输入端（曲边），只要有一个高电平 1，输出的高电平就为 1；只有全部输入低电平 0，输出才为 0。（尖头为输出）。（**或 1 为 1，全 0 则 0**）

![](https://i-blog.csdnimg.cn/blog_migrate/6fff34a09472b64f7271d2133373519e.png)**与门（直边）**。它可以有多个输入，但只能有一个输出。执行的是与的逻辑，在输入端（直边），只要有一个是低电平 0，输出就是 0；只有全部输入 1，输出才为 1。（**与 0 为 0，全 1 则 1**）

![](https://i-blog.csdnimg.cn/blog_migrate/534af52c3736109128b9d1c9a17b5fda.png)**非门（三角号加个圈）**。它只有一个输入，一个输出；输入 1 就输出 0，输入 0 就输出 1，执行的是非得逻辑（**圈为输出，取反**）

![](https://i-blog.csdnimg.cn/blog_migrate/a2c7fda9931a3de26fabff71465362e9.png)数据选择器（一个梯形）。有多个输入，一个输出，在侧面有选择控制端，根据控制端的数据，从输入选择一个接到输出。

 ![](https://i-blog.csdnimg.cn/blog_migrate/838d79ed384609196dcb40f11c9c58fa.png)表示 20 根线，代表 20 个通道